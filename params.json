{"name":"Joshua Bloch's API Design Bumper Sticker ","tagline":"","body":"### Joshua Bloch: Bumper-Sticker API Design.\r\n\r\n[Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch) is a well-known and respected member of the Java community. He is the author of Effective Java, the quintessential must-read book for every Java developer.\r\nSome years ago, he delivered a talk on API design. Despite my lack of experience in the field, I can safely assume it may be one of its kind. You can watch the full video here. \r\n* [How to Design a Good API and why it matters](https://www.youtube.com/watch?v=heh4OeB9A-c)\r\n* [Link to PDF of presentation](http://lcsd05.cs.tamu.edu/slides/keynote.pdf)\r\n\r\nHe also captured the highlights of his talk in what he refers to as bumper-sticker of API design\r\n\r\nPlease note that all of the content below is from his presentation and not my original content. I created this page as a quick reference\r\n\r\n##All programmers are API designers\r\nGood programs are modular, and intermodular boundaries define APIs. Good modules get reused\r\n\r\n##APIs can be among your greatest assets or liabilities.\r\nGood APIs create long-term customers; bad ones create long-term support nightmares..\r\n\r\n##Public APIs, like diamonds, are forever.\r\nYou have one chance to get it right so give it your best.\r\n##APIs should be easy to use and hard to misuse.\r\nIt should be easy to do simple things; possible to do complex things; and impossible, or at least difficult, to do wrong things.\r\n\r\n##APIs should be self-documenting\r\nIt should rarely require documentation to read code written to a good API. In fact, it should rarely require documentation to write it.\r\n\r\n##When designing an API, first gather requirements—with a healthy degree of skepticism.\r\nPeople often provide solutions; it's your job to ferret out the underlying problems and find the best solutions.\r\n\r\n##Structure requirements as use-cases\r\nthey are the yardstick against which you'll measure your API.\r\n\r\n##Early drafts of APIs should be short,\r\ntypically one page with class and method signatures and one-line descriptions. This makes it easy to restructure the API when you don't get it right the first time.\r\n\r\n##Code the use-cases against your API before you implement it,\r\neven before you specify it properly. This will save you from implementing, or even specifying, a fundamentally broken API.\r\n\r\n##Maintain the code for uses-cases as the API evolves.\r\nNot only will this protect you from rude surprises, but the resulting code will become the examples for the API, the basis for tutorials and tests.\r\n\r\n##Example code should be exemplary.\r\nIf an API is used widely, its examples will be the archetypes for thousands of programs. Any mistakes will come back to haunt you a thousand fold.\r\n\r\n##You can't please everyone so aim to displease everyone equally.\r\nMost APIs are overconstrained.\r\n\r\n##Expect API-design mistakes due to failures of imagination.\r\nYou can't reasonably hope to imagine everything that everyone will do with an API, or how it will interact with every other part of a system.\r\n\r\n##API design is not a solitary activity.\r\nShow your design to as many people as you can, and take their feedback seriously. Possibilities that elude your imagination may be clear to others.\r\n\r\n##Avoid fixed limits on input sizes. \r\nThey limit usefulness and hasten obsolescence.\r\n\r\n##Names matter.\r\nStrive for intelligibility, consistency, and symmetry. Every API is a little language, and people must learn to read and write it. If you get an API right, code will read like prose.\r\n\r\n##If it's hard to find good names, go back to the drawing board.\r\nDon't be afraid to split or merge an API, or embed it in a more general setting. If names start falling into place, you're on the right track.\r\n\r\n##When in doubt, leave it out.\r\nIf there is a fundamental theorem of API design, this is it. It applies equally to functionality, classes, methods, and parameters. Every facet of an API should be as small as possible, but no smaller. You can always add things later, but you can't take them away. Minimizing conceptual weight is more important than class- or method-count.\r\n\r\n##Keep APIs free of implementations details. \r\nThey confuse users and inhibit the flexibility to evolve. It isn't always obvious what's an implementation detail: Be wary of overspecification\r\n\r\n##Minimize mutability. \r\nImmutable objects are simple, thread-safe, and freely sharable.\r\n\r\n##Documentation matters.\r\nNo matter how good an API, it won't get used without good documentation. Document every exported API element: every class, method, field, and parameter.\r\n\r\n##Consider the performance consequences of API design decisions, but don't warp an API to achieve performance gains.\r\nLuckily, good APIs typically lend themselves to fast implementations.\r\n\r\n##When in Rome, do as the Romans do\r\nAPIs must coexist peacefully with the platform, so do what is customary. It is almost always wrong to â€œtransliterateâ€  an API from one platform to another.\r\n\r\n##Minimize accessibility\r\nwhen in doubt, make it private. This simplifies APIs and reduces coupling.\r\n\r\n##Subclass only if you can say with a straight face that every instance of the subclass is an instance of the superclass.\r\nExposed classes should never subclass just to reuse implementation code.\r\n\r\n##Design and document for inheritance or else prohibit it.\r\nThis documentation takes the form of selfuse patterns: how methods in a class use one another. Without it, safe subclassing is impossible.\r\n\r\n##Don't make the client do anything the library could do.\r\nViolating this rule leads to boilerplate code in the client, which is annoying and error-prone.\r\n\r\n##Obey the principle of least astonishment.\r\nEvery method should do the least surprising thing it could, given its name. If a method doesn't do what users think it will, bugs will result\r\n\r\n##Fail fast.\r\nThe sooner you report a bug, the less damage it will do. Compile-time is best. If you must fail at run-time, do it as soon as possible.\r\n\r\n##Provide programmatic access to all data available in string form.\r\nOtherwise, programmers will be forced to parse strings, which is painful. Worse, the string forms will turn into de facto APIs.\r\n\r\n##Overload with care\r\nIf the behaviors of two methods differ, it's better to give them different names.\r\n\r\n##Use the right data type for the job. \r\nFor example, don't use string if there is a more appropriate type.\r\n\r\n##Use consistent parameter ordering across methods.\r\nOtherwise, programmers will get it backwards.\r\n\r\n##Avoid long parameter lists, \r\nespecially those with multiple consecutive parameters of the same type.\r\n\r\n##Avoid return values that demand exceptional processing. \r\nClients will forget to write the specialcase code, leading to bugs. For example, return zero-length arrays or collections rather than nulls.\r\n\r\n##Throw exceptions only to indicate exceptional conditions. \r\nOtherwise, clients will be forced to use exceptions for normal flow control, leading to programs that are hard to read, buggy, or slow.\r\n\r\n##Throw unchecked exceptions \r\nunless clients can realistically recover from the failure.\r\n\r\n##API design is an art, not a science. \r\nStrive for beauty, and trust your gut. Do not adhere slavishly to the above heuristics, but violate them only infrequently and with good reason.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}